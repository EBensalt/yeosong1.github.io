
# CPP Module 03

## 디스크립션
이 모듈은 C++에 있는 상속 inheritance 에 관한 것이다.

## 목표
OOP (Object Oriented Programming) 객체지향 프로그래밍

## 기술
명령형 프로그래밍 (Imperative programming)
객체 지향 프로그래밍 (Object-oriented programming)
Rigor (엄밀함???)


----------------------
## 서브젝트

### 제너럴 룰
- 헤더에 구현된 모든 기능(템플릿의 경우는 제외) 및 보호되지 않은 헤더는 exercise에 0을 의미합니다. ??????
- 모든 **출력은 표준 출력으로** 하며, 특별히 지정하지 않는 한 **개행(\n)으로 끝납니다.**
- 부과된 파일 이름 뒤에는 문자letter, 클래스 이름, 함수 이름, 메서드 이름이 와야합니다.
- 기억하십시오: 이제 더 이상 C가 아닌 C++로 코딩하고 있습니다. 따라서:
  - 다음 기능은 **금지**되어 있으며 사용시 0점 처리를 받습니다. 묻지도 따지지도 마시오: ***alloc, *printf, free*
  - 기본적으로 표준 라이브러리의 모든 것을 사용할 수 있습니다. **그러나** C++ 버전의 함수를 사용하는 것이 현명할 것입니다.
    당신은 C에서 익숙합니다. 당신이 아는 것을 유지하는 대신, 결국 이건 새로운 언어입니다. 그리고 **네, 안돼요**,
    써도 될 때까지 STL을 사용할 수 없습니다.(즉, 모듈08 전에는 안됨). 이는 include <algorithm>을 요구하기 전까진
    벡터/리스트/맵/등등 다 안된다는 뜻입니다.
- 실제로, 명시적으로 금지된 기능 또는 기계의 사용은 묻지도 따지지도 않고 0점 처리됩니다.
- 또한 달리 명시되지 않는 한 C++ 키워드 "`**using namespace**`"및 "`**friend**`"는 금지되어 있습니다. 그들의 사용은 질문없이 -42점으로 처리 될 것입니다.
- 클래스와 관련된 파일은 달리 명시되지 않는 한 항상 `**ClassName.hpp**` 및 `**ClassName.cpp**`입니다.
- Turn-in 디렉토리는 ex00/, ex01/, ... , exn/.
- 예제를 철저하게 읽어야합니다. exercise의 설명에서서는 명확하지 않은 요구 사항을 포함하고 있을 수 있습니다.
  만약 뭔가 모호해 보인다면, 당신이 C++를 충분히 이해하지 못한 것입니다.
- 앞에서부터 배운 C++ 도구는 사용할 수 있으므로, external 라이브러리는 사용할 수 없습니다. 그리고 물어보기 전에
  그것은 또한 C++11과 파생 모델, `Boost` 또는 C++ 없으면 못사는 놀라운 기술을 갖춘 친구가 알려준 그 어떤 것도 안된다는 뜻입니다.
- 상당한 양의 클래스들을 제출해야 할 수도 있습니다. 이것은 좋아하는 텍스트 편집기를 스크립팅할 수 없다면 지루해 보일 수 있습니다.
- 시작하기 전에 각 exercise를 **완전히** 읽으십시오! 진짜로, 하세요.
- 사용할 컴파일러는 `clang++`입니다.
- 코드는 다음 플래그를 사용하여 컴파일해야합니다. `-Wall -Wextra -Werror`.
- 당신의 각 includes는 다른 includes들과 독립적으로 포함될 수 있어야 합니다. Includes는 분명히 그들이 의존하는 다른 모든 include를 포함해야합니다.
- 궁금할까봐: C++에서는 코딩 스타일이 적용되지 않습니다. 원하는 스타일 아무거나 사용 가능, 제한 없음. 하지만, 동료 평가자가 읽을 수 없는 것은 채점할 수 없는 코드입니다.
- 이제 중요한 사항 : 서브젝트에 명시적으로 설명하지 않는 한 **프로그램에 의해 채점되지 않습니다**. 따라서, 여러분은 exercise를 선택하는 방법에 있어서 어느 정도의 자유가 주어집니다. 하지만, 각 exercise의 제한조건에 유의하고, **게으르지 마세요**, 여러분은 그들이 제공하는 **많은** 것들을 놓칠 거예요!
- 제출하는 파일에 일부 관계없는 파일이 있는 것은 문제가 되지 않습니다. 요청한 파일보다 더 많은 파일로 코드를 분리할 수도 있습니다.
  결과가 프로그램에 의해 채점되지 않는 한, 자유롭게 하세요.
- 비록 서브젝트의 exercise가 짧더라도, 여러분이 여러분에게 기대하는 것을 완전히 이해하고 가능한 최선의 방법으로 했다는 것을 확실히 하기 위해
  시간을 들이는 것은 가치가 있습니다.
- 오딘의 이름으로, 토르의 이름으로! 머리를 써라!!!

### exercise 00: Aaaaand... OPEN!
- 제출할 디렉토리 : ex00/
- 제출할 파일 : FragTrap.cpp FragTrap.hpp main.cpp
- 금지 함수: 없음

여기서는 FR4G-TP 공격 로봇/슈박스를 모델링하는 클래스를 만들어야 합니다.
클래스는 FragTrap이라고 부를거고 다음과 같은 지정된 값으로 초기화된 attribute를 가집니다:

• Hit points (100)
• Max hit points (100)
• Energy points (100)
• Max energy points (100)
• Level (1)
• Name (Parameter of constructor)
• Melee attack damage (30)
• Ranged attack damage (20)
• Armor damage reduction (5)
또한 보다 실제와 같은 기능을 제공하는 몇 가지 기능도 제공합니다:
• rangedAttack(std::string const & target)
• meleeAttack(std::string const & target)
• takeDamage(unsigned int amount)
• beRepaired(unsigned int amount)

이 모든 기능에서 무슨 일이 일어나는지 설명할 수 있는 것을 보여야 합니다.
예를 들어, 원거리 공격 기능은 다음과 같은 라인을 따라 무언가를 표시할 수 있습니다.
FR4G-TP <이름>이 사정거리에서 <표적>을 공격하여 [손상] 지점을 발생시킵니다!
시공자와 파괴자는 또한 사람들이 그것들을 볼 수 있도록 무언가를 표시해야 한다.
호명되다 이러한 메시지가 재미있는 참조인 경우 보너스 포인트(사용자가 있는 경우)
FR4G-TP가 무엇인지 모르며, 구글을 통해 최소한 몇 개의 잘 선택된 인용구를 사용합니다.)
몇 가지 제약 조건:
• 히트 포인트 수는 최대 히트 포인트 수를 초과할 수 없습니다. 동일
에너지 지점 예를 들어 HP를 너무 많이 수리하는 경우
최대 HP 수 같은 방법으로, 0 아래로 떨어질 수 없습니다.
• 손상을 고려할 때, 갑옷의 손상 감소를 고려해야 합니다.
vaulthunter_dot_exe(std::string const & target) 함수를 추가하여 종료합니다.
반랜덤 공격을 가할 수 있습니다. 매번 호출될 때마다 그렇게 만드십시오.
(놀랍게도) 최소한 5의 풀에서 무작위로 선택된 재미있는 공격을 선택한다.
공격 당신이 이것을 성취하기 위해 사용하기를 원하는 것은 무엇이든 좋습니다, 그러나 늘 그렇듯이, 더 많은
우아한 방법일수록 좋다. 이 기능을 실행하려면 25개의 에너지 포인트가 필요합니다. 네가 만약
에너지 포인트가 충분하지 않습니다. 인쇄하는 것 외에는 아무 것도 할 수 없습니다.
에너지가 다 떨어졌어요.
코드가 다음과 같은지 입증할 수 있는 충분한 테스트를 통해 기본 기능을 제공합니다.
기능상의



### exercise 01: Serena, my love!
### exercise 02: 반복적인 작업
### exercise 03: 이제 더 쉽지!
### exercise 04: 궁극의 공격 신발장

