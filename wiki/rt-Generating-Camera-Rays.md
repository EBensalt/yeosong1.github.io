# 카메라 레이 만들기

Contents
- [레이 정의 하기](#레이-정의-하기)
- [카메라 레이 만들기](rt-카메라-레이-만들기)
- [표준 좌표계](rt-표준좌표계)
- [소스 코드](https://www.scratchapixel.com/code.php?id=7&origin=/lessons/3d-basic-rendering/ray-tracing-generating-camera-rays)

**키워드: camera ray, primary ray, camera, ray-tracing, ray.**

## 선수강 조건
- 포인트, 벡터, 행렬, 카메라 및 삼각법 사용(기하학 레슨 참고) 
- 서로 다른 좌표계의 정점(vertex)과 벡터 간의 변환([Computing the Pixel of a 3D Point](https://www.scratchapixel.com/lessons/3d-basic-rendering/3d-viewing-pinhole-camera)레슨 참고)
(기하학에서 Vertex(vertices, vertexes) = "정점" = 2개 이상의 곡선, 선, 모서리 등이 만나는 점)
- 3D Viewing: the Pinhole Camera Model 레슨에 나오는 개념들
- 이 레슨을 읽기 전에 위 내용들을 다뤘는지 확인하십시오.

## 이건 뭐에 관한 레슨인가
Ray-Tracing에 대한 입문 강좌에서, 우리는 이미 가시성 문제를 해결을 위해 레이 트레이싱이 어떻게 사용되는지에 대해 이미 빠르게 언급했습니다.
3D 렌더링에서 보이는 표면을 결정하는 프로세스는, 카메라를 통해 장면의 어느 부분을 볼 수 있는지 결정하기 위해 사용된다는 걸 기억해보자.
우리는 가시성을 계산하기 위해 레이 트레이싱을 사용할 수 있다.(이건 이미 이전 레슨에서 설명했음)
이미지의 각 픽셀을 통해 광선을 캐스팅하고 이 광선이 교차하는(교차 한다면) 가장 가까운 물체를 찾음으로써 계산할 수 있다.
레이 캐스팅이 광선들과 표면들 간의 교차를 계산하는 기술이라는 것도 복기해보자.
레이 트레이싱을 사용해서 가시성을 계산하는 것은 레이 캐스팅이라고도 합니다.. ??

> 유클리드 공간에 장애물 세트가 주어지면, 그 공간을 연결하는 선분이 장애물과 교차하지 않으면 공간의 두 점이 서로에게 보인다고 할 수 있다.
> (위키피디아, '가시성'의 정의)

레이 트레이싱을 사용해서 가시성을 해결하기 위해 이미지를 생성하려면?
이미지 내의 모든 픽셀을 루프 시켜서
각 픽셀에 대해 광선을 만들고
이 광선을 장면에 캐스트해서
이 광선과 표면들 사이의 가능한 교차를 찾아야 한다.

이 광선들을 primary rays(혹은 camera, eye rays)라고 부른다.
이것들이 처음으로 장면에 캐스트 되는 광선들이기 때문이다.
(secondary rays는 그림자, 반사, 굴절 등등을 계산할 때 쓰인다)

광선이 표면과 교차하는지 확인하려면,
이 광선에 대해 가능한 교차점이 있는지
장면 속의 각 물체를 테스트를 해야한다.

광선은 1개 이상의 표면을 교차할 것이다. 보이는 표면은 교차 거리가 가장 가까운 표면이다.
교차 거리를 이용해서 우리는 광선의 원점(=origin // primary ray일 경우, 카메라)와 교차점으로부터의 거리를 구할 수 있다.

~~~
for (int j = 0; j < height; ++j) { 
    for (int i = 0; i < width; ++i) { 
        // primary ray 생성 (이게 이 레슨의 내용이다)
        ... 
        float tnear = INFINITY; // closest intersection, set to INFINITY to start with 
        for (int k = 0; k < numObjects; ++k) { 
             float t = INFINITY; // 현재의 오브젝트가 있으면 교차 
             if objects[k]->intersect(pimaryRay, tnear) && t < tnear) { 
                 tnear = t; 
                 framebuffer= objects[k].color; 
            } 
        } 
    } 
} 
~~~

이 레슨에서
1. 광선의 개념을 공식화할 것이다.
2. 핀홀 카메라를 본뜨기 위해 primary rays를 생성하는 방법을 공식화 할 것이다.

우리가 primary rays가 어떻게 생성되는지를 이해하고 나면
다음 단계는 광선-도형 간의 교차를 계산하는 몇 가지 테크닉을 학습하는 것이다.

이것들은 레이 트레이싱으로 3D 오브젝트 이미지를 만들기 위한 최소한의 요구사항이다.

~~~
ray-tracing 광선 추적 및 perspective projection 원근 투영에 대한 참고 사항 :
핀홀 카메라 모델은 CG에서 가장 간단하게 시뮬레이션 할 수 있습니다.
래스터 화와 마찬가지로 레이 트레이싱에도 사용할 모델입니다. 이미지들은 이 모델로 형성됩니다.
핀홀 카메라로 그려진 3D에서 2D로의 매핑은 perspective projection임을 기억하세요.
~~~
이 챕터에서 우리는 광선에 관한 몇 가지 유용한 것들을 배울 것입니다.
다음 챕터에서 우리는 어떻게 primary rays가 계산되는지 배울 것입니다.

## 레이 정의 하기

앞의 레슨에서 선언했듯이,
> 레이 트레이싱은 점과 점 사이의 가시성을 계산하는 기술이다.
> 이건 간단히 광선이 수학적으로(+컴퓨터 프로그램 내에서) 점(공간에서 광선의 시작점)으로 정의할 수 있다는 개념에 기반하고 있다.
> 레이 트레이싱의 기반이 되는 아이디어는, 여러 기하도형과 이 광선과의 교차를 계산하는 수학적인 해결법을 찾는다는 점이다.
> 여기서 여러 타입의 기하도형이란: 삼각형, 이차초곡면(앞으로 우리가 배울 레슨 내용 중 하나), NURBs(비균일 유리 B-스플라인(Non-Uniform Rational B-spline) 등.
> 이게 진짜로 레이 트레이싱에 관한 모든 것입니다.

우리가 이 레슨에서 설명할 부분은(특히 이 챕터에서는) 
1. 광선의 개념
2. 이론에서 광선을 정의 할 수 있는 방법
3. 프로그래밍에서 광선을 정의 할 수 있는 방법
입니다.

광선 하나를 정의하기 위해서는 딱 2개의 변수가 필요합니다. 점, 벡터.
점은 광선의 원점(origin)을, 벡터는 방향(direction)을 나타냅니다.
(점은 프로그래밍 방식으로 간단히 vec3f로 정의 하겠음)
방향은, 일반적으로, 정규화 되어야함을 염두에 두세요.

~~~
//광선을 정의하기 위한 최소 요구사항: 위치, 방향

Vec3f orig; // 광선의 origin
Vec3f dir; // 광선의 (정규화 된)direction
~~~

이 점과 방향이 합쳐졌을때 나타내는 것은 반직선(half-line)이다. (반직선: 하나의 점에서 시작해서 한 방향으로 무한히 뻗어나가는 직선.)
수학적으로 어느 점이건 이 half-line의 모든 점은 다음과 같이 정의할 수 있다.

~~~
P = origin + t * dir
~~~

$$
P는
위치값 origin에서
시작해 dir방향으로
t만큼 이어지는 반직선 위의
t만큼 간 자리의 그 점이다. 
$$

t는 원점 origin에서부터 ~ 반직선 위의 어느 점 까지의 거리다.
이 변수 t는 음수, 양수 둘 다 가능하다.
t가 음수면, 광선 위의 점은 원점보다 뒤쳐져있고
t가 양수면, 점 P는 원점보다 "앞"에 있다. 
실제로 우리가 레이 트레이싱을 쓸 때, 우리는 보통 광선 원점 "앞에" 위치한 표면-광선 간 교차점 찾기에만 관심이 있다.
이것은 우리가 t가 양수인 경우에 광선-표면 간 교차만 고려할 것이라는 얘기다.

~~~
// 광선의 origin과 direction 정의
Vec3f orig = ...;
Vec3f dir = ...;
float t = INFINITY;
// 이 광선이 물체와 교차하는가? 교차점이 발견되면 intersect()가 true 리턴.
if (object.intersect(orig, dir, t) && t >0) {
    // = 유효한 교차. (hit point가 광선의 원점보다 앞에 있음)
    ...
 }
~~~

수학적 관점에서, 위 방정식을 [parametric equation](https://en.wikipedia.org/wiki/Parametric_equation)방정식이라고 한다.
반직선은 파라메트릭 변수 t(또는 파라미터)의 함수인 방정식으로 설명됩니다............

광선-지오메트리 교차 루틴은 항상 매개 변수 t로 교차점(있는 경우)을 반환합니다.
다시 말해, 교차점을 찾은 경우 광선-지오메트리 교차 루틴은
광선 원점에서 해당 교차점까지의 거리를 계산하여 이 정보를 사용자에게 반환합니다.
여기에서 위에서 소개 한 광선 파라 메트릭 방정식을 사용하여 3D 공간에서 교차점 또는 적중 점의 위치를 쉽게 계산할 수 있습니다.

~~~
// 광선의 origin과 direction 정의
Vec3f orig = ...; 
Vec3f dir = ...; 
float t = INFINITY; // 물체와의 교차 거리(있는 경우). 시작하려면 매우 큰 숫자로 설정!
// 이 광선이 물체와 교차하는가? 교차점이 발견되면 intersect()가 true 리턴.
if (object.intersect(orig, dir, t) && t > 0) { 
    // = 유효한 교차.(hit point가 광선의 원점보다 앞에 있음) hit point를 t를 이용해서 계산
    Vec3f hitPoint = orig + dir * t; 
} 
~~~

이것이 진짜로 광선에 관한 모든 것입니다. 프로그래밍 관점에서 광선을 C ++ 클래스로 정의 할 수도 있습니다.

~~~
class Ray 
{ 
public: 
    Ray(), orig(0), dir(0,0,-1) {} 
    Ray(const Vec3f &o, const Vec3f &d) : orig(o), dir(d) {} 
    // etc.
    ... 
    Vec3f orig; 
    Vec3f dir; 
}; 
~~~

일부 프로그래머는 이 클래스에 tmin 및 tmax 거리와 같은 멤버 변수를 더 추가하려고 합니다.
tmin, tmax는 t에 대해 유효한 값의 범위를 정의합니다.
즉, 광선-지오메트리 루틴이 [tmin, tmax] 범위 내에 포함되지 않은 t에 대한 값을 반환하면
실제로 t가 0보다 큰 경우에도 교점이 없는 것입니다.

~~~
class Ray 
{ 
public: 
    Ray(), orig(0), dir(0,0,-1), tMin(0.1), tMax(1000) {} 
    Ray(const Vec3f &o, const Vec3f &d) : orig(o), dir(d), tMin(0.1), tMax(1000) {} 
    // etc.
    ... 
    Vec3f orig; 
    Vec3f dir; 
    float tMin, tMax; 
}; 
 
Ray ray; 
// 광선의 direction과 origin 설정.
ray.orig = ...; 
ray.dir = ...; 
float t = INFINITY; 
if (object.intersect(ray, t) && t >= ray.tMin && t <= r.tMax) { 
     // = 유효한 교차..
     ... 
} 
~~~

Ray 클래스에 원하는만큼 매개 변수를 추가 할 수 있습니다.
Ray 클래스 사용 여부를 결정할 수 있습니다.
이것은 전적으로 개인의 취향과 요구 사항에 달려 있습니다.
프로그램에서이 데이터를 나타내는 방식에 대한 규칙은 없습니다.
일부 프로그래머는 가장 가까운 가시 표면에 대한 거리 t (교차점을 찾을 때 광선 형상 루틴에서 설정),
적중 객체에 대한 포인터 등과 같은 정보를 Ray 클래스에 추가하려고합니다.
이 정보를 광선 변수와 분리하고 대신 Intersection이라는 구조체 또는 클래스에 저장합니다.
다시 말하지만 광선 원점과 광선 방향을 최소한 정의해야하는 것 외에도 다른 모든 방법은 원하는 방식으로 수행 할 수 있습니다(선택 사항).

~~~
프로그래밍에서 유용할 수도 있는 한 가지 방법은 기본, 그림자, 반사, 굴절 등과 같은 유형에 따라 광선에 레이블을 지정하는 것입니다.
통계를 수집하는 데 사용할 수 있습니다.(ex 주어진 장면 렌더링에 그림자가 몇 개나 캐스팅되었는지 알고 싶은 경우)
그리고 코드에서 광선 유형에 따라 다른 함수를 호출하는 데 사용할 수 있습니다. 이것은 또한 일반적인 관행입니다.
~~~

## 광선은 어따 쓰는가?

광선은 거의 모든 곳에 쓰일 수 있다. 
보통 가시성 문제를 푸는 데에 쓰인다. (오브젝트의 색 정보를 모으고, 그림자를 계산하고..)
우리가 이 강의에서 배울 광선의 타입은 "camera rays 또는 primary rays"라고 불리는 것이다.

프레임 안의 각각의 픽셀에 우리는 장면에 쏠 하나의 카메라 레이를 구성해야한다.
카메라 레이가 물체와 교차하면, 그 교차점에서 물체의 색을 계산하고, 그 색을 상응하는 픽셀에 할당한다.
이것이 간단하게 본 '레이 트레이싱으로 CG 이미지 생성하는 법'이다.
우리는 primary rays(카메라의 원점을 시작점으로 하는, 장면에 쏘아진 첫 번째 광선)과 음영 처리에 사용하는 secondary rays(그림자, 확산, 반사, 투과 등)을 구별 할 수 있습니다. secondary rays는 primary rays의 교점에서 생성됩니다..
secondary rays의 direction은 유형에 따라 다릅니다.
ex) 그림자(=빛의 방향으로 광선 쏘기), 반사(=반사 방향으로 광선 쏘기), 굴절(=굴절 방향으로 광선 쏘기)등.

## 다음 시간에는..
다음 장에서는 프레임의 각 픽셀에 camera ray를 initalize 하는 법을 배우겠습니다.
이 시점에서 이미지를 얻기 위해 우리가 해야할 것은! 1.간단한 광선-물체 교차 루틴 2.이미지 파일 형식으로 저장하기 뿐 입니다.

------------------------
Chapter 1 of 4         [다음 장 ->](rt-카메라-레이-만들기)
