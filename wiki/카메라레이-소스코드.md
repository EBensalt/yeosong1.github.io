# 카메라 레이 생성하기 소스코드

```c++
//[header]
// Whitted 스타일의 레이 트레이싱을 구현하는 방법을 보여주는 간단한 프로그램
//[/header]
//[compile]
// camerarays.cpp 및 geometry.h 파일을 폴더로 다운로드합니다.
// 쉘/터미널을 열고 파일이 저장된 곳에서 다음 명령을 실행합니다.
//
// c++ -o camerarays camerarays.cpp -O3 -std=c++11 -DMAYA_STYLE
//
// ./camerarays로 실행합니다. Photoshop이나 어느 프로그램에서 ./out.png 파일을 엽니다.
// PPM 파일을 읽습니다
//[/compile]
//[ignore]
// 저작권 (C) 2012 www.scratchapixel.com
//
// 이 프로그램은 자유 소프트웨어입니다 :
// 자유 소프트웨어 재단, 라이센스 버전 3 또는 이후 버전에서
// 배포한 GNU 일반 공중 사용 허가서의 조건에 따라서
// 재배포 및 수정할 수 있습니다.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//[/ignore]


#include <cstdio>
#include <cstdlib>
#include <memory>
#include <vector>
#include <utility>
#include <cstdint>
#include <iostream>
#include <fstream>
#include <cmath>
#include <limits>

#include "geometry.h"

const float kInfinity = std::numeric_limits<float>::max();

inline
float clamp(const float &lo, const float &hi, const float &v)
{ return std::max(lo, std::min(hi, v)); }

inline
float deg2rad(const float &deg)
{ return deg * M_PI / 180; }

struct Options
{
    uint32_t width;
    uint32_t height;
    float fov;
};

class Light
{
public:
    Light() {}
};

class Object
{
 public:
    Object() {}
    virtual ~Object() {}
};

// [comment]
// 이 함수는 현재 많은 기능을 수행하지 않습니다. 그것은 단순히 광선 방향을 취하고 있고
// 그걸 색으로 바꿉니다. 광선 방향 좌표가 [-1,1] 범위 안에 있습니다.
// 정규화하기 위해 1을 더하고 결과를 2로 나눕니다.
// [/comment]
Vec3f castRay(
    const Vec3f &orig, const Vec3f &dir,
    const std::vector<std::unique_ptr<Object>> &objects,
    const std::vector<std::unique_ptr<Light>> &lights,
    const Options &options,
    uint32_t depth)
{
    Vec3f hitColor = (dir + Vec3f(1)) * 0.5;
    return hitColor;
}

// [comment]
// 메인 렌더 함수입니다. 여기에서 이미지의 모든 픽셀을 반복하고  
// 기본 광선을 생성하고 이러한 광선을 장면에 캐스트합니다. 
// 프레임 버퍼의 내용이 파일에 저장됩니다.
// [/comment]
void render(
    const Options &options,
    const std::vector<std::unique_ptr<Object>> &objects,
    const std::vector<std::unique_ptr<Light>> &lights)
{
    Matrix44f cameraToWorld;
    Vec3f *framebuffer = new Vec3f[options.width * options.height];
    Vec3f *pix = framebuffer;
    float scale = tan(deg2rad(options.fov * 0.5));
    float imageAspectRatio = options.width / (float)options.height;
    // [comment]
    // 광선 원점(카메라->월드 매트릭스를 사용해서 좌표가 (0,0,0)인 점을
    // world space로 변환한 카메라 원점이기도 함)을 변환하는 것을 잊지 마십시오.
    // [/comment]
    Vec3f orig;
    cameraToWorld.multVecMatrix(Vec3f(0), orig);
    for (uint32_t j = 0; j < options.height; ++j) {
        for (uint32_t i = 0; i < options.width; ++i) {
            // [comment]
            // rimary ray direction을 생성합니다. screen space에서 광선의 x, y 위치를 계산합니다.
            // 이는 z = 1 에 이미지 평면에 점을 제공합니다.
            // 여기에서 결과 vec3f 변수를 정규화하여 direction을 간단히 계산합니다.
            // 이것은 이미지 평면 위의 점과 카메라 원점 사이의 벡터를 camera space에서 (0,0,0)으로 가져오는 것과 유사합니다:
            //
            // ray.dir = normalize(Vec3f(x,y,-1) - Vec3f(0));
            // [/comment]
#ifdef MAYA_STYLE
            float x = (2 * (i + 0.5) / (float)options.width - 1) * scale;
            float y = (1 - 2 * (j + 0.5) / (float)options.height) * scale * 1 / imageAspectRatio;
#elif

            float x = (2 * (i + 0.5) / (float)options.width - 1) * imageAspectRatio * scale;
            float y = (1 - 2 * (j + 0.5) / (float)options.height) * scale;
#endif
            // [comment]
            // 카메라->월드 매트릭스를 사용하여 광선 방향을 변환하는 것을 잊지 마십시오.
            // [/comment]
            Vec3f dir;
            cameraToWorld.multDirMatrix(Vec3f(x, y, -1), dir);
            dir.normalize();
            *(pix++) = castRay(orig, dir, objects, lights, options, 0);
        }
    }

    // PPM 이미지에 결과 저장 (Windows에서 컴파일하는 경우 이 플래그 유지)
	std::ofstream ofs("./out.ppm", std::ios::out | std::ios::binary);
    ofs << "P6\n" << options.width << " " << options.height << "\n255\n";
    for (uint32_t i = 0; i < options.height * options.width; ++i) {
        char r = (char)(255 * clamp(0, 1, framebuffer[i].x));
        char g = (char)(255 * clamp(0, 1, framebuffer[i].y));
        char b = (char)(255 * clamp(0, 1, framebuffer[i].z));
        ofs << r << g << b;
    }

    ofs.close();

    delete [] framebuffer;
}

// [comment]
// 프로그램의 주요 기능에서 장면을 생성하고 (객체와 조명 생성) 
// 렌더 옵션 (이미지 너비와 높이, 최대 재귀 깊이, FOV 등)을 설정합니다. 
// 그런 다음 render function()를 호출합니다.
// [/comment]
int main(int argc, char **argv)
{
    // 장면 만들기 (객체와 조명 추가)
    std::vector<std::unique_ptr<Object>> objects;
    std::vector<std::unique_ptr<Light>> lights;
    
    // 옵션 설정
    Options options;
    options.width = 640;
    options.height = 480;
    options.fov = 90;

    // 마지막으로, 렌더링
    render(options, objects, lights);

    return 0;
}
```
