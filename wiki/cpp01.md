# CPP Module 01 서브젝트

## 제너럴 룰

<details>
<summary> <b> 제너럴 룰 보기 </b>  </summary><br>
<div markdown="1">
  
- 헤더 안에 구현된 모든 기능(템플릿의 경우는 제외) 및 보호되지 않은 헤더는 exercise 0점을 의미합니다.
- 모든 **출력은 표준 출력으로** 하며, 특별히 지정하지 않는 한 **개행(\n)으로 끝납니다.**
- 부과된 파일 이름 뒤에는 letter, 클래스 이름, 함수 이름, 메서드 이름이 와야합니다.
- 기억하십시오: 이제 더 이상 C가 아닌 C++로 코딩하고 있습니다. 따라서:
  - 다음 기능은 **금지**되어 있으며 사용시 0점 처리를 받습니다. 묻지도 따지지도 마시오: ***alloc, *printf, free*
  - 기본적으로 표준 라이브러리의 모든 것을 사용할 수 있습니다. **그러나** C++ 버전의 함수를 사용하는 것이 현명할 것입니다.
    당신은 C에 익숙합니다. 당신이 아는 것을 유지하는 대신, C++ 버전의 함수를 사용하는 것이 현명할 것입니다. 결국 이건 새로운 언어입니다.
  - 그리고 **네, 안돼요.** 써도 될 때까지는 [STL](https://www.cplusplus.com/reference/stl/)을 사용할 수 없습니다.(즉, 모듈08 전에는 안됨).
  - 이는 include <algorithm>을 필요로 하는 모든 것은--벡터/리스트/맵/등등--다 안된다는 뜻입니다.
- 명시적으로 금지된 기능 또는 기계의 사용은 묻지도 따지지도 않고 0점 처리됩니다.
- 또한, 달리 명시되지 않는 한 C++ 키워드 **using namespace**및 **friend**는 금지되어 있습니다.
  - 그들의 사용은 질문없이 **-42점**으로 처리 될 것입니다.
- 클래스와 관련된 파일은 달리 명시되지 않는 한 항상 **ClassName.hpp** 및 **ClassName.cpp**입니다.
- Turn-in 디렉토리는 **ex00/**, **ex01/**, ... , **exn/**.
- 예제를 철저하게 읽어야합니다. exercise의 설명에서는 명확하지 않았던 요구 사항을 포함하고 있을 수 있습니다.
  만약 뭔가 모호해 보인다면, 당신이 **C++**를 충분히 이해하지 못한 것입니다.
- 앞에서부터 배운 **C++** 도구는 사용할 수 있으므로, external 라이브러리는 사용할 수 없습니다. 그리고 물어보기 전에 말해드려요:
  - 그것은 또한 **C++11과 파생 모델**, **Boost** 또는 C++ 없으면 못사는 놀라운 기술을 갖춘 친구가 알려준 그 어떤 것도 안된다는 뜻입니다.
  - = 범위 기반 for문 C++11이니까 사용 금지..
- 상당한 양의 클래스들을 제출해야 할 수도 있습니다. 이것은 좋아하는 텍스트 편집기를 스크립팅할 수 없다면 지루해 보일 수 있습니다.
- 시작하기 전에 각 exercise를 **완전히** 읽으십시오! 진짜로요, 읽으세요.
- 사용할 컴파일러는 **clang++**입니다.
- 코드는 다음 플래그를 사용하여 컴파일해야합니다: **-Wall -Wextra -Werror**
- 당신의 각 includes는 다른 includes들과 독립적으로 포함될 수 있어야 합니다. Includes는 분명히 그들이 의존하는 다른 모든 include를 포함해야합니다.
- 궁금할까봐: **C++에서는 코딩 스타일이 적용되지 않습니다.** 원하는 스타일 아무거나 사용 가능, 제한 없음. **하지만, 동료 평가자가 읽을 수 없는 코드는 채점 받을 수 없겠죠**
- 이제 중요한 사항 : 서브젝트에 명시적으로 설명하지 않는 한 **프로그램에 의해 채점되지 않습니다**. 따라서, 여러분은 exercise를 선택하는 방법에 있어서 어느 정도의 자유가 주어집니다. 하지만, 각 exercise의 제한조건에 유의하고, **게으르지 마세요**, 연습문제들이 제공해야되는 **많은 것들을 놓치게 될거예요!**
- 제출하는 파일에 일부 관계없는 파일이 있는 것은 문제가 되지 않습니다. 요청한 파일보다 더 많은 파일로 코드를 분리할 수도 있습니다.
  결과가 프로그램에 의해 채점되지 않는 한, 자유롭게 하세요.
- 비록 서브젝트의 exercise가 짧더라도, 알아야 할 것을 확실히 이해하고, 가능한 최선의 방법으로 풀었다는 것을 확실히 하기 위해 시간을 들이는 것은 가치가 있습니다.
- 오딘의 이름으로, 토르의 이름으로! 머리를 쓰세요!!!
  
 </div> 
 </details>
 <BR>
  
## ex00  네발짐승의 힙 -- 클래스를 힙 또는 스택에 불러오는 방법

시작하기 좋은 쉬운 문제.

- [x] Pony 클래스를 만드세요.
  - [x] 뭐든간에 포니를 적절하게 설명한다고 생각하는 것을 포함하는 클래스로 만드세요.
- [x] ponyOnTheHeap 함수를 만드세요 -- Pony를 힙에 할당하세요 -- 그냥 새 Pony 클래스 `변수`를 선언하면 된다.
- [x] ponyOnTheStack 함수를 만드세요 -- Pony를 스택에 할당하세요 -- Pony 클래스 `*변수`를 선언하면 된다.
  - [x] new
  - [x] delete
- [x] 두 경우 모두 함수가 제어권을 넘긴 후에는 Pony 객체가 없어야합니다.(당신의 메인도 평가때 이것을 증명해야 합니다!)

- [x] main 코드 -- 의도 한대로 작동 한 것을 증명할 수있는 충분한 코드를 메인에 제공합니다.

## ex01 배관 문제 -- 메모리 할당/해제 -- 스택에 할당하게 바꾸거나, 힙에 할당하고 지우는 내용을 넣거나 하여간 누수 없애기

다시, 간단한 연습문제.

- 아래의 함수에 있는 메모리 누수를 없앤 후 제출해야한다.
- 물론 메모리 할당/할당해제 작업을 하는 문제입니다.
- 단순히 변수를 제거하거나 실제로 뽑아내지 않고 건들기만 하면 그것은 오답으로 간주합니다..

~~~C++
void memoryLeak()
{
    std::string* panther = new std::string("String panther");
    std::cout << *panther << std::endl;
}
~~~

## ex02 뇌 뽑기 -- 힙 스택 제거 복사

- [x] **Zombie class**를 만드세요.
  - [x] **type**, **name**을 포함하도록 하고 (더 추가해도 됨)
  - [x] 아래 문장 같은 거를 출력할 멤버 함수 **announce()** 를 포함
  - 예시) `<name (type)> Braiiiiiinnss...`
  - 좀비의 name과 type을 출력하기만 하면 진짜 뭐든지 원하는 대로 써도 됩니다.
- [x] **ZombieEvent class**를 만드세요.
  - [x] **setZombieType 함수**를 포함해야 합니다.
  - [x] **Zombie* newZombie(std::string name)함수**를 포함
    - [x] 이 함수는 정해진 type과 name으로 좀비를 생성해서 리턴함.
  - [x] type 을 저장하는 오브젝트를 포함
- [x] **randomChump 함수**를 만드세요.
  - [x] 이 함수는 랜덤 이름으로 좀비를 만듭니다. [srand,rand,time](https://blockdmask.tistory.com/308)
  - [x] 그리고 스스로 announce 합니다.
  - 랜점을 지정하는 방식은, 이름 풀에서 진짜로 랜덤으로 정해지기만 하면 어떤 방법을 고르든 상관없어요.
- [x] **main**을 포함한 완전한 프로그램을 내세요.
  - 요구사항에 맞게 만든 내용을 충분히 증명할 수 있게 메인을 짜세요.
  - 예시) 새로 만들어진 좀비들을 announce 시킨다든지
- 이번 연습문제의 실제 요점 :
  - [x] 좀비는 적절한 때에 파괴되어야합니다.(즉, 더 이상 필요하지 않을 때에요)
  - [x] 적절한 방식으로 할당해야합니다. 어떤 때는 스택에 배치하는게 적절하고, 어떤 때는 힙이 더 나은 선택입니다.
  - 좋은 점수를 받기 위해 당신이 한 일을 정당화해야합니다. (왜 그렇게 했는지 디펜스를 잘해보세요)

## ex03 뇌 뎌! -- 생성자 소멸자

- **ZombieHorde class** -- 위에서 만든 **Zombie class** 재활용해서 쓰세요.
  - **int N을 받는 생성자**를 포함.
  - 생성시 N Zombie 객체를 allocate 해야한다. 
  - 랜덤 name으로
  - 저장
  - announce() 함수를 포함. 이 함수는 포함된 Zombie 객체마다 announce()를 호출한다.
- 모든 Zombie 객체는 단일 할당 해야하고(?), ZombiHorde가 파괴될 때 해제해야합니다.
- 늘 그렇듯이, main과 테스트를 제공하고 선택을 정당화하세요.

## ex04 안녕하세요 뇌 입니다 -- 포인터와 레퍼런스

- "HI THIS IS BRAIN"이 포함된 문자열을 만드는 프로그램을 만듭니다.
- 그걸 가리키는 포인터랑 레퍼런스를 만듭니다.
- 포인터를 사용해서 보여주세요.
- 레퍼런스(참조)를 사용해서 보여주세요.

그게 다예요, 속임수는 없어요.

## ex05 안녕 뇌, 나는 사람이야 -- this, 레퍼런스,

- **Brain 클래스**를 만듭니다. 두뇌에 적합하다고 생각되는 모든 것을 사용하여.
  - **identify() 함수** 포함
    - 16진수 단위로 메모리에 있는 뇌의 주소를 포함하는 문자열을 16진수 포맷으로 반환하는 함수이다.
    - 접두사 0x 예시) "0x194F87EA"

----------------------------------------------- 여기서 부터 다시 
- **Human 클래스**
  - constant Brain attribute 속성을 가진
  - 같은 수명으로 만듭니다.
  
두뇌의 식별() 기능을 호출하는 식별() 기능이 있고
결과를 반환합니다.

이제 이 코드가 두 개의 동일한 주소를 컴파일하고 표시하도록 합니다:

~~~C++
int main()
{
  Human bob;
    std::cout << bob.identify() << std::endl;
    std::cout << bob.getBrain().identify() << std::endl;
}
~~~

- 위 코드를 main 코드로 설정해야 합니다.
- human 클래스랑 brain 클래스를 잘 작동시키기 위해 무엇을 추가했든, 정당화되어야 한다.
  - ("어, 네, 그게 될 때까지 만지작거렸어요." 말고 다른 얘길 하세요)

## ex06 

## ex07 sed 프로그램 구현
- 파일 이름과 두 개의 문자열(비어 있지 않은 s1과 s2)을 받는 **replace**라는 프로그램을 만듭니다.
- 거기 나오는 모든 s1을 s2으로 바꿉니다. 파일을 열고 내용을 FILENAME.replace에 씁니다. 
- 물론 오류를 최대한 처리하고, C 파일 조작 함수는 사용하지 않습니다. 그건 치팅이고 치팅은 나쁘니까 그죠?
- 프로그램이 작동하는 것을 보여주기 위해 몇 가지 테스트 파일을 제출합니다.
